// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/model/pdata"
)

// MetricSettings provides common settings for a particular metric.
type MetricSettings struct {
	Enabled bool `mapstructure:"enabled"`
}

// MetricsSettings provides settings for kubeletstatsreceiver metrics.
type MetricsSettings struct {
	CPUTime               MetricSettings `mapstructure:"cpu.time"`
	CPUUtilization        MetricSettings `mapstructure:"cpu.utilization"`
	FilesystemAvailable   MetricSettings `mapstructure:"filesystem.available"`
	FilesystemCapacity    MetricSettings `mapstructure:"filesystem.capacity"`
	FilesystemUsage       MetricSettings `mapstructure:"filesystem.usage"`
	MemoryAvailable       MetricSettings `mapstructure:"memory.available"`
	MemoryMajorPageFaults MetricSettings `mapstructure:"memory.major_page_faults"`
	MemoryPageFaults      MetricSettings `mapstructure:"memory.page_faults"`
	MemoryRss             MetricSettings `mapstructure:"memory.rss"`
	MemoryUsage           MetricSettings `mapstructure:"memory.usage"`
	MemoryWorkingSet      MetricSettings `mapstructure:"memory.working_set"`
	NetworkErrors         MetricSettings `mapstructure:"network.errors"`
	NetworkIo             MetricSettings `mapstructure:"network.io"`
	VolumeAvailable       MetricSettings `mapstructure:"volume.available"`
	VolumeCapacity        MetricSettings `mapstructure:"volume.capacity"`
	VolumeInodes          MetricSettings `mapstructure:"volume.inodes"`
	VolumeInodesFree      MetricSettings `mapstructure:"volume.inodes.free"`
	VolumeInodesUsed      MetricSettings `mapstructure:"volume.inodes.used"`
}

func DefaultMetricsSettings() MetricsSettings {
	return MetricsSettings{
		CPUTime: MetricSettings{
			Enabled: true,
		},
		CPUUtilization: MetricSettings{
			Enabled: true,
		},
		FilesystemAvailable: MetricSettings{
			Enabled: true,
		},
		FilesystemCapacity: MetricSettings{
			Enabled: true,
		},
		FilesystemUsage: MetricSettings{
			Enabled: true,
		},
		MemoryAvailable: MetricSettings{
			Enabled: true,
		},
		MemoryMajorPageFaults: MetricSettings{
			Enabled: true,
		},
		MemoryPageFaults: MetricSettings{
			Enabled: true,
		},
		MemoryRss: MetricSettings{
			Enabled: true,
		},
		MemoryUsage: MetricSettings{
			Enabled: true,
		},
		MemoryWorkingSet: MetricSettings{
			Enabled: true,
		},
		NetworkErrors: MetricSettings{
			Enabled: true,
		},
		NetworkIo: MetricSettings{
			Enabled: true,
		},
		VolumeAvailable: MetricSettings{
			Enabled: true,
		},
		VolumeCapacity: MetricSettings{
			Enabled: true,
		},
		VolumeInodes: MetricSettings{
			Enabled: true,
		},
		VolumeInodesFree: MetricSettings{
			Enabled: true,
		},
		VolumeInodesUsed: MetricSettings{
			Enabled: true,
		},
	}
}

type metricCPUTime struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cpu.time metric with initial data.
func (m *metricCPUTime) init() {
	m.data.SetName("cpu.time")
	m.data.SetDescription("CPU time")
	m.data.SetUnit("s")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
}

func (m *metricCPUTime) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCPUTime) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCPUTime(settings MetricSettings) metricCPUTime {
	m := metricCPUTime{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricCPUUtilization struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cpu.utilization metric with initial data.
func (m *metricCPUUtilization) init() {
	m.data.SetName("cpu.utilization")
	m.data.SetDescription("CPU utilization")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricCPUUtilization) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val float64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCPUUtilization) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCPUUtilization(settings MetricSettings) metricCPUUtilization {
	m := metricCPUUtilization{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricFilesystemAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills filesystem.available metric with initial data.
func (m *metricFilesystemAvailable) init() {
	m.data.SetName("filesystem.available")
	m.data.SetDescription("Filesystem available")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricFilesystemAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFilesystemAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFilesystemAvailable(settings MetricSettings) metricFilesystemAvailable {
	m := metricFilesystemAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricFilesystemCapacity struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills filesystem.capacity metric with initial data.
func (m *metricFilesystemCapacity) init() {
	m.data.SetName("filesystem.capacity")
	m.data.SetDescription("Filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricFilesystemCapacity) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFilesystemCapacity) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFilesystemCapacity(settings MetricSettings) metricFilesystemCapacity {
	m := metricFilesystemCapacity{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricFilesystemUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills filesystem.usage metric with initial data.
func (m *metricFilesystemUsage) init() {
	m.data.SetName("filesystem.usage")
	m.data.SetDescription("Filesystem usage")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricFilesystemUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFilesystemUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFilesystemUsage(settings MetricSettings) metricFilesystemUsage {
	m := metricFilesystemUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.available metric with initial data.
func (m *metricMemoryAvailable) init() {
	m.data.SetName("memory.available")
	m.data.SetDescription("Memory available")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryAvailable(settings MetricSettings) metricMemoryAvailable {
	m := metricMemoryAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryMajorPageFaults struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.major_page_faults metric with initial data.
func (m *metricMemoryMajorPageFaults) init() {
	m.data.SetName("memory.major_page_faults")
	m.data.SetDescription("Memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryMajorPageFaults) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryMajorPageFaults) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryMajorPageFaults(settings MetricSettings) metricMemoryMajorPageFaults {
	m := metricMemoryMajorPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryPageFaults struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.page_faults metric with initial data.
func (m *metricMemoryPageFaults) init() {
	m.data.SetName("memory.page_faults")
	m.data.SetDescription("Memory page_faults")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryPageFaults) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryPageFaults) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryPageFaults(settings MetricSettings) metricMemoryPageFaults {
	m := metricMemoryPageFaults{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryRss struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.rss metric with initial data.
func (m *metricMemoryRss) init() {
	m.data.SetName("memory.rss")
	m.data.SetDescription("Memory rss")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryRss) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryRss) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryRss(settings MetricSettings) metricMemoryRss {
	m := metricMemoryRss{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryUsage struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.usage metric with initial data.
func (m *metricMemoryUsage) init() {
	m.data.SetName("memory.usage")
	m.data.SetDescription("Memory usage")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryUsage) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryUsage) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryUsage(settings MetricSettings) metricMemoryUsage {
	m := metricMemoryUsage{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricMemoryWorkingSet struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills memory.working_set metric with initial data.
func (m *metricMemoryWorkingSet) init() {
	m.data.SetName("memory.working_set")
	m.data.SetDescription("Memory working_set")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricMemoryWorkingSet) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricMemoryWorkingSet) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricMemoryWorkingSet(settings MetricSettings) metricMemoryWorkingSet {
	m := metricMemoryWorkingSet{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNetworkErrors struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills network.errors metric with initial data.
func (m *metricNetworkErrors) init() {
	m.data.SetName("network.errors")
	m.data.SetDescription("Network errors")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNetworkErrors) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Interface, pdata.NewAttributeValueString(interfaceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNetworkErrors) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNetworkErrors(settings MetricSettings) metricNetworkErrors {
	m := metricNetworkErrors{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricNetworkIo struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills network.io metric with initial data.
func (m *metricNetworkIo) init() {
	m.data.SetName("network.io")
	m.data.SetDescription("Network IO")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeSum)
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pdata.MetricAggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricNetworkIo) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
	dp.Attributes().Insert(A.Interface, pdata.NewAttributeValueString(interfaceAttributeValue))
	dp.Attributes().Insert(A.Direction, pdata.NewAttributeValueString(directionAttributeValue))
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricNetworkIo) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricNetworkIo(settings MetricSettings) metricNetworkIo {
	m := metricNetworkIo{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVolumeAvailable struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills volume.available metric with initial data.
func (m *metricVolumeAvailable) init() {
	m.data.SetName("volume.available")
	m.data.SetDescription("The number of available bytes in the volume.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVolumeAvailable) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVolumeAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVolumeAvailable) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVolumeAvailable(settings MetricSettings) metricVolumeAvailable {
	m := metricVolumeAvailable{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVolumeCapacity struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills volume.capacity metric with initial data.
func (m *metricVolumeCapacity) init() {
	m.data.SetName("volume.capacity")
	m.data.SetDescription("The total capacity in bytes of the volume.")
	m.data.SetUnit("By")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVolumeCapacity) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVolumeCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVolumeCapacity) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVolumeCapacity(settings MetricSettings) metricVolumeCapacity {
	m := metricVolumeCapacity{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVolumeInodes struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills volume.inodes metric with initial data.
func (m *metricVolumeInodes) init() {
	m.data.SetName("volume.inodes")
	m.data.SetDescription("The total inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVolumeInodes) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVolumeInodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVolumeInodes) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVolumeInodes(settings MetricSettings) metricVolumeInodes {
	m := metricVolumeInodes{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVolumeInodesFree struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills volume.inodes.free metric with initial data.
func (m *metricVolumeInodesFree) init() {
	m.data.SetName("volume.inodes.free")
	m.data.SetDescription("The free inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVolumeInodesFree) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVolumeInodesFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVolumeInodesFree) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVolumeInodesFree(settings MetricSettings) metricVolumeInodesFree {
	m := metricVolumeInodesFree{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

type metricVolumeInodesUsed struct {
	data     pdata.Metric   // data buffer for generated metric.
	settings MetricSettings // metric settings provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills volume.inodes.used metric with initial data.
func (m *metricVolumeInodesUsed) init() {
	m.data.SetName("volume.inodes.used")
	m.data.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
	m.data.SetUnit("1")
	m.data.SetDataType(pdata.MetricDataTypeGauge)
}

func (m *metricVolumeInodesUsed) recordDataPoint(start pdata.Timestamp, ts pdata.Timestamp, val int64) {
	if !m.settings.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntVal(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricVolumeInodesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricVolumeInodesUsed) emit(metrics pdata.MetricSlice) {
	if m.settings.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricVolumeInodesUsed(settings MetricSettings) metricVolumeInodesUsed {
	m := metricVolumeInodesUsed{settings: settings}
	if settings.Enabled {
		m.data = pdata.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user settings.
type MetricsBuilder struct {
	startTime                   pdata.Timestamp
	metricCPUTime               metricCPUTime
	metricCPUUtilization        metricCPUUtilization
	metricFilesystemAvailable   metricFilesystemAvailable
	metricFilesystemCapacity    metricFilesystemCapacity
	metricFilesystemUsage       metricFilesystemUsage
	metricMemoryAvailable       metricMemoryAvailable
	metricMemoryMajorPageFaults metricMemoryMajorPageFaults
	metricMemoryPageFaults      metricMemoryPageFaults
	metricMemoryRss             metricMemoryRss
	metricMemoryUsage           metricMemoryUsage
	metricMemoryWorkingSet      metricMemoryWorkingSet
	metricNetworkErrors         metricNetworkErrors
	metricNetworkIo             metricNetworkIo
	metricVolumeAvailable       metricVolumeAvailable
	metricVolumeCapacity        metricVolumeCapacity
	metricVolumeInodes          metricVolumeInodes
	metricVolumeInodesFree      metricVolumeInodesFree
	metricVolumeInodesUsed      metricVolumeInodesUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pdata.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(settings MetricsSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		startTime:                   pdata.NewTimestampFromTime(time.Now()),
		metricCPUTime:               newMetricCPUTime(settings.CPUTime),
		metricCPUUtilization:        newMetricCPUUtilization(settings.CPUUtilization),
		metricFilesystemAvailable:   newMetricFilesystemAvailable(settings.FilesystemAvailable),
		metricFilesystemCapacity:    newMetricFilesystemCapacity(settings.FilesystemCapacity),
		metricFilesystemUsage:       newMetricFilesystemUsage(settings.FilesystemUsage),
		metricMemoryAvailable:       newMetricMemoryAvailable(settings.MemoryAvailable),
		metricMemoryMajorPageFaults: newMetricMemoryMajorPageFaults(settings.MemoryMajorPageFaults),
		metricMemoryPageFaults:      newMetricMemoryPageFaults(settings.MemoryPageFaults),
		metricMemoryRss:             newMetricMemoryRss(settings.MemoryRss),
		metricMemoryUsage:           newMetricMemoryUsage(settings.MemoryUsage),
		metricMemoryWorkingSet:      newMetricMemoryWorkingSet(settings.MemoryWorkingSet),
		metricNetworkErrors:         newMetricNetworkErrors(settings.NetworkErrors),
		metricNetworkIo:             newMetricNetworkIo(settings.NetworkIo),
		metricVolumeAvailable:       newMetricVolumeAvailable(settings.VolumeAvailable),
		metricVolumeCapacity:        newMetricVolumeCapacity(settings.VolumeCapacity),
		metricVolumeInodes:          newMetricVolumeInodes(settings.VolumeInodes),
		metricVolumeInodesFree:      newMetricVolumeInodesFree(settings.VolumeInodesFree),
		metricVolumeInodesUsed:      newMetricVolumeInodesUsed(settings.VolumeInodesUsed),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// Emit appends generated metrics to a pdata.MetricsSlice and updates the internal state to be ready for recording
// another set of data points. This function will be doing all transformations required to produce metric representation
// defined in metadata and user settings, e.g. delta/cumulative translation.
func (mb *MetricsBuilder) Emit(metrics pdata.MetricSlice) {
	mb.metricCPUTime.emit(metrics)
	mb.metricCPUUtilization.emit(metrics)
	mb.metricFilesystemAvailable.emit(metrics)
	mb.metricFilesystemCapacity.emit(metrics)
	mb.metricFilesystemUsage.emit(metrics)
	mb.metricMemoryAvailable.emit(metrics)
	mb.metricMemoryMajorPageFaults.emit(metrics)
	mb.metricMemoryPageFaults.emit(metrics)
	mb.metricMemoryRss.emit(metrics)
	mb.metricMemoryUsage.emit(metrics)
	mb.metricMemoryWorkingSet.emit(metrics)
	mb.metricNetworkErrors.emit(metrics)
	mb.metricNetworkIo.emit(metrics)
	mb.metricVolumeAvailable.emit(metrics)
	mb.metricVolumeCapacity.emit(metrics)
	mb.metricVolumeInodes.emit(metrics)
	mb.metricVolumeInodesFree.emit(metrics)
	mb.metricVolumeInodesUsed.emit(metrics)
}

// RecordCPUTimeDataPoint adds a data point to cpu.time metric.
func (mb *MetricsBuilder) RecordCPUTimeDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricCPUTime.recordDataPoint(mb.startTime, ts, val)
}

// RecordCPUUtilizationDataPoint adds a data point to cpu.utilization metric.
func (mb *MetricsBuilder) RecordCPUUtilizationDataPoint(ts pdata.Timestamp, val float64) {
	mb.metricCPUUtilization.recordDataPoint(mb.startTime, ts, val)
}

// RecordFilesystemAvailableDataPoint adds a data point to filesystem.available metric.
func (mb *MetricsBuilder) RecordFilesystemAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricFilesystemAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordFilesystemCapacityDataPoint adds a data point to filesystem.capacity metric.
func (mb *MetricsBuilder) RecordFilesystemCapacityDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricFilesystemCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordFilesystemUsageDataPoint adds a data point to filesystem.usage metric.
func (mb *MetricsBuilder) RecordFilesystemUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricFilesystemUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryAvailableDataPoint adds a data point to memory.available metric.
func (mb *MetricsBuilder) RecordMemoryAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryMajorPageFaultsDataPoint adds a data point to memory.major_page_faults metric.
func (mb *MetricsBuilder) RecordMemoryMajorPageFaultsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryMajorPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryPageFaultsDataPoint adds a data point to memory.page_faults metric.
func (mb *MetricsBuilder) RecordMemoryPageFaultsDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryPageFaults.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryRssDataPoint adds a data point to memory.rss metric.
func (mb *MetricsBuilder) RecordMemoryRssDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryRss.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryUsageDataPoint adds a data point to memory.usage metric.
func (mb *MetricsBuilder) RecordMemoryUsageDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryUsage.recordDataPoint(mb.startTime, ts, val)
}

// RecordMemoryWorkingSetDataPoint adds a data point to memory.working_set metric.
func (mb *MetricsBuilder) RecordMemoryWorkingSetDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricMemoryWorkingSet.recordDataPoint(mb.startTime, ts, val)
}

// RecordNetworkErrorsDataPoint adds a data point to network.errors metric.
func (mb *MetricsBuilder) RecordNetworkErrorsDataPoint(ts pdata.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	mb.metricNetworkErrors.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue)
}

// RecordNetworkIoDataPoint adds a data point to network.io metric.
func (mb *MetricsBuilder) RecordNetworkIoDataPoint(ts pdata.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	mb.metricNetworkIo.recordDataPoint(mb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue)
}

// RecordVolumeAvailableDataPoint adds a data point to volume.available metric.
func (mb *MetricsBuilder) RecordVolumeAvailableDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVolumeAvailable.recordDataPoint(mb.startTime, ts, val)
}

// RecordVolumeCapacityDataPoint adds a data point to volume.capacity metric.
func (mb *MetricsBuilder) RecordVolumeCapacityDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVolumeCapacity.recordDataPoint(mb.startTime, ts, val)
}

// RecordVolumeInodesDataPoint adds a data point to volume.inodes metric.
func (mb *MetricsBuilder) RecordVolumeInodesDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVolumeInodes.recordDataPoint(mb.startTime, ts, val)
}

// RecordVolumeInodesFreeDataPoint adds a data point to volume.inodes.free metric.
func (mb *MetricsBuilder) RecordVolumeInodesFreeDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVolumeInodesFree.recordDataPoint(mb.startTime, ts, val)
}

// RecordVolumeInodesUsedDataPoint adds a data point to volume.inodes.used metric.
func (mb *MetricsBuilder) RecordVolumeInodesUsedDataPoint(ts pdata.Timestamp, val int64) {
	mb.metricVolumeInodesUsed.recordDataPoint(mb.startTime, ts, val)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pdata.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}

// Attributes contains the possible metric attributes that can be used.
var Attributes = struct {
	// Direction (Direction of flow of bytes/operations (receive or transmit).)
	Direction string
	// Interface (Name of the network interface.)
	Interface string
}{
	"direction",
	"interface",
}

// A is an alias for Attributes.
var A = Attributes

// AttributeDirection are the possible values that the attribute "direction" can have.
var AttributeDirection = struct {
	Receive  string
	Transmit string
}{
	"receive",
	"transmit",
}
